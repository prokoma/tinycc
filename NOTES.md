# Notes

## TinyC Language

- functions can be defined only at the top level (global) - done, Parser
- structs (`AstStructDecl`) & typedefs (`AstFunPtrDecl`) have their own namespace
- variables and functions are lexically scoped - done, SemanticAnalysis
  - one name cannot be declared twice on the same level (same lexical frame) once as a function and once as a variable - done, SemanticAnalysis
- global variables, functions and structs can have one or multiple forward declarations - done, SemanticAnalysis
  - all of them must be type compatible
  - there can be only one definition
- `switch` statement must contain unique case values - done, SemanticAnalysis
- function declarations must contain unique argument names - done, SemanticAnalysis
- only complete struct types can be used in the program
  - the struct is available as an incomplete type in its own definition
  - pointers are always complete, so recursive structs are possible
- assignment must contain lvalue on left side
- recursive function pointers are not allowed (function cannot take or return pointer to the same type)
- `foo == &foo`, both are pointers to function `foo`
- `(*(&foo))()` and `foo()` is the same

```c
int foo(double); // declaration
int foo(double x){ return x; } // definition
```

### Casting

- implicit casts:
  - `char` <-> `int`
  - `char` <-> `double`
  - `int` <-> `double`
  - any`*` -> `void *` (can assign any pointer to `void*` variable/argument)

- explicit casts (`cast<Ty>(Expr)`)
  - all implicit casts
  - `void*` -> any`*`

## IR

- phi nodes
  - generated by mem2reg pass using dominance frontiers
- basic blocks
  - mutable reference to immutable list of instructions

## Optimizations

- mem2reg

## Instruction Scheduling

- ignore at first
- it will be done at IR level if at all

## Instruction Selection

- tree patterns, builder for operands
- `Context`
  - provides access to virtual register for a given IR instruction
  - if a special register is required, ask for it from `Context` and emit `AsmMov`
  - `emit()` method for emitting t86 instructions (with virtual registers)
- pattern is `(ctx: Context) => VirtualReg`
- cannot use scala patterns, because algos need pattern sizes
- find roots for each IR instruction (instruction without uses as operand)
- tiles which match IrLoad will be more complex
  - we need to be sure that the loaded value is unchanged at the root of the tile (emission point)
- preserve basic blocks

### Algorithms

- maximal munch (top-down greedy)

## Register Allocation

1. unlimited registers
2. simple local allocator 
3. graph coloring

- after allocation, remove nop `AsmMov`s emitted because of constraints

## Output

- insert function prologue and epilogue
- patching

## TODO

- binary operator in type analysis
- arrays
- better error reporting for parser
- rewrite Parsers
- IR
- IrBuilder
- AstToIrLowering
- printer & parser for IR
- extract middle end to its own jar
- instruction selection
- register allocation
- asm output